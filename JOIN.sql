-- 카테시안 곱 CARTESIAN PRODUCT (= 데카르트 곱, 크로스 조인(CROSS JOIN), 교차 조인)
-- 행 수는 14 * 4 = 56개
SELECT *
FROM EMP, DEPT
ORDER BY EMPNO
;
-- EMP의 DEPTNO 와 DEPT의 DEPTNO를 연결하여 조인
-- 실제 사용 시 모든 컬럼을 조회한다고 해도 출력할 열을 하나하나 직접 명시해야 함
SELECT *
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO
;
-- 등가조인 : 테이블을 연결한 후, 출력 행을 각 테이블의 특정 열에 일치한 데이터를 기준으로 선정하는 방식
-- 등가조인(EQUI JOIN) = 내부조인(INNER JOIN) = 단순조인(SIMPLE JOIN)
-- 이름을 특별하게 명시하지 않으면 등가조인을 사용하는 방식이다.
-- 다음은 두 테이블이 DEPTNO를 갖고있기 때문에 누구의 것인지 정확히 명시되지 않아 오류 발생
SELECT EMPNO, ENAME, DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
;
-- 기본적으로 데카르트 곱 현상이 일어나지 않게 하는 데 필요한 조건식의 최소 개수는 조인 테이블 개수에서 하나를 뺀 값이다.
SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.SAL <= 2500
AND E.EMPNO <= 9999
ORDER BY E.EMPNO
;
-- 비등가 조인(NON-EQUI JOIN)은 등가 조인 방식 외의 방식
-- 열의 일치 여부를 기준으로 테이블을 조인하는 등가 조인 방식은 아래와 같은 쿼리를 만들기 힘듬
-- 급여 등급을 맞춰 주려면 사원의 급여 금액이 일치하는 것이 아니라 최소급여(LOSAL)와 최대급여(HISAL) 사이에 있어야 하기 때문
-- 이 경우 BETWEEN A AND B를 사용한다.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, S.GRADE, S.LOSAL, S.HISAL
FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL
;
-- 자체 조인(SELF JOIN) : 하나의 테이블을 여러 개의 테이블처럼 활용
-- FROM절에 같은 테이블을 여러 번 명시하되 테이블의 별칭만 다르게 지정하는 방식
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO
;
-- 외부 조인(OUTER JOIN) : 두 테이블 간 조인 수행에서 조인 기준 열의 어느 한 쪽이 NULL이어도 강제로 출력하는 방식
-- 왼쪽 외부 조인(LEFT OUTER JOIN) : WHERE TABLE1.COL1 = TABLE2.COL1(+)
-- 오른쪽 외부 조인(RIGHT OUTER JOIN) : WHERE TABLE1.COL1 (+)= TABLE2.COL1
-- 왼쪽 외부 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO
;
-- 오른쪽 외부 조인
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR (+)= E2.EMPNO
ORDER BY E1.EMPNO
;
-- SQL-99 표준 문법으로 배우는 조인
-- NATURAL JOIN : 조인 대상이 되는 두 테이블에 이름과 자료형이 같은 열을 찾은 후 그 열을기준으로 등가 조인을 해주는 방식
-- 공통 열 DEPTNO를 이용하여 자동으로 등가 조인됨(별칭 붙이지 않기)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, E.EMPNO
;
-- JOIN ~ USING : 기존 등가 조인을 대신하는 조인 방식
-- 위와 마찬가지로 공통 열에 별칭을 붙이지 않는다.
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL >= 3000
ORDER BY DEPTNO, E.EMPNO
;
-- JOIN ~ ON : 가장 법용성있는 조인 방식
-- 위와 다르게 별칭 붙임
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
WHERE SAL <= 3000
ORDER BY DEPTNO, E.EMPNO
;
-- 왼쪽 외부 조인
-- 기존 : WHERE TABLE1.COL1 = TABLE2.COL1(+)
-- SQL-99 : FROM TABLE1 LEFT OUTER JOIN ON (조인 조건식)
-- 오른쪽 외부 조인
-- 기존 : WHERE TABLE1.COL1 (+)= TABLE2.COL1
-- SQL-99 : FROM TABLE1 RIGHT OUTER JOIN ON (조인 조건식)
-- 전체쪽 외부 조인 (FULL OUTER JOIN)
-- 기존 : WHERE TABLE1.COL1 (+)= TABLE2.COL1
-- SQL-99 : FROM TABLE1 FULL OUTER JOIN ON (조인 조건식)
SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_ENAME
FROM EMP E1 FULL OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO
;
-- 복습 (문제.1 과 문제.2는 같은 내용을 출력)
SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING (DEPTNO)
WHERE SAL >= 3000
AND E.MGR IS NOT NULL
ORDER BY DEPTNO, E.EMPNO
;
-- Q1.1
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO
AND E.SAL > 2000
ORDER BY D.DEPTNO, E.SAL
;
-- Q1.2
SELECT DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM DEPT D JOIN EMP E USING(DEPTNO)
WHERE E.SAL > 2000
ORDER BY DEPTNO, E.SAL
;
-- Q2.1
SELECT D.DEPTNO, D.DNAME, AVG(E.SAL) AS AVG_SAL, MAX(E.SAL) AS MAX_SAL, MIN(E.SAL) AS MIN_SAL, COUNT(*)
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO
GROUP BY D.DEPTNO, D.DNAME
ORDER BY DEPTNO
;
-- Q2.2
SELECT DEPTNO, D.DNAME, AVG(E.SAL) AS AVG_SAL, MAX(E.SAL) AS MAX_SAL, MIN(E.SAL) AS MIN_SAL, COUNT(*)
FROM DEPT D JOIN EMP E USING(DEPTNO)
GROUP BY DEPTNO, D.DNAME
ORDER BY DEPTNO
;
-- Q3.1
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO(+)
ORDER BY D.DEPTNO, E.ENAME
;
-- Q3.2
SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM DEPT D LEFT OUTER JOIN EMP E ON(D.DEPTNO = E.DEPTNO)
ORDER BY DEPTNO, E.ENAME
;

-- Q4.1
SELECT D.DEPTNO, D.DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_EMPNO
FROM DEPT D, EMP E1, SALGRADE S, EMP E2
WHERE D.DEPTNO = E1.DEPTNO(+)
AND E1.SAL BETWEEN S.LOSAL(+) AND S.HISAL(+)
AND E1.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO, E1.ENAME
;
-- Q4.2
SELECT D.DEPTNO, D.DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO, S.LOSAL, S.HISAL, S.GRADE, E2.EMPNO AS MGR_EMPNO, E2.ENAME AS MGR_EMPNO
FROM EMP E1 RIGHT OUTER JOIN DEPT D ON (D.DEPTNO = E1.DEPTNO)
LEFT OUTER JOIN SALGRADE S ON (E1.SAL BETWEEN S.LOSAL AND S.HISAL)
LEFT OUTER JOIN EMP E2 ON (E1.MGR = E2.EMPNO)
ORDER BY D.DEPTNO, E1.ENAME
;